# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014 Brad Miller, David Ranum, Created using Runestone Interactive
# This file is distributed under the same license as the How to Think Like a Computer Scientist package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: How to Think Like a Computer Scientist 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-03-25 13:50-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:16
msgid "A Programming Example"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:18
msgid "Let's develop a non-trivial GUI program to demonstrate the material presented in the previous lessons. We will develop a GUI Whack-a-mole game where a user tries to click on \"moles\" as they randomly pop up out of the \"ground.\""
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:23
msgid "This discussion will take you through an *incremental development* cycle that creates a program in well-defined stages. While you might read a finished computer program from \"top to bottom,\" that is not how it was developed. For a typical GUI program development, you are encouraged to go through these stages:"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:29
msgid "Using scratch paper, physically draw a rough sketch of your user interface."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:30
msgid "Create the basic structure of your program and create the major frames that will hold the widgets needed for your program's interface. Give the frames an initial size and color so that you can visually see them, given that there are no widgets inside of them to determine their size."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:34
msgid "Incrementally add all of the widgets you need for your program and size and position them appropriately."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:36
msgid "Create your callback functions, stub them out, and assign them to appropriate events. Verify that the events are executing the correct functions."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:38
msgid "Incrementally implement the functionality needed for each callback function."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:40
msgid "When you develop code using *incremental development* your program should always be executable. You continually add a few lines of code and then test them. If errors occur you almost always know were the errors came from! They came from the lines of code you just added."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:46
msgid "A Whack-a-mole Game"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:48
msgid "Step 1: Make sure you have a reasonable GUI design and implementation plan before you start coding. Draw a sketch of your initial design on paper and consider how a user will interact with your program."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:55
msgid "Initial design of a Whack-a-mole game"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:57
msgid "Step 2: Create the basic structure of your interface using appropriate ``frame`` widgets. You will need to give a size to the frames because they will contain no widgets, which is how a frame typically gets its size. It is also suggested that you give each frame a unique color so it is easy to see the area of the window it covers. Here is a basic start for our whack-a-mole game (`whack_a_mole_v1.py`_):"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:86
msgid "Step 3: Incrementally add appropriate widgets to each frame. Don't attempt to add all the widgets at once. The initial design conceptualized the moles as buttons, so a grid of buttons was added to the left frame, one button for each mole. The exact size of the \"mole field\" needs to be determined at a future time, so initialize a CONSTANT that can be used to easily change it later.  (`whack_a_mole_v2.py`_)"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:138
msgid "Continue to add appropriate widgets for the right frame. The final result is shown below, but recognize that it was developed little by little. (`whack_a_mole_v2.py`_)"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:228
msgid "Step 4: Create a callback function for each event that will cause something to happen in your program. Stub these functions out with a single print statement in each one. Bind an event to each callback function. Now test your program and make sure each event causes the correct print-line in the Python console. (`whack_a_mole_v4.py`_)"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:340
msgid "Step 5: Add appropriate functionality to the callback functions. This is where the functional logic of your particular application resides. In the case of our whack-a-mole game, we need to be able to count the number of times a user clicks on a mole when it is visible. And we need the moles to appear and disappear at random intervals. Originally each mole was a button widget, but the border around each button was distracting, so they were changed to label widgets. Two images were used to represent a mole: one image is a solid color that matches the frame's background, and the other image is a picture of a mole. By replacing the image used for each label we can make the moles visible or invisible. A label normally does not have an associated callback, so we ``bind`` a left mouse click event, ``\"<ButtonPress-1>\"`` to each label. We can determine whether the mouse click is a \"hit\" or a \"miss\" by examining the label under the click to see which image is currently set to the label. We use timer events to change the image on each label. Also notice the use of a messagebox to protect the program from accidental quitting. The end result is shown below. (`whack_a_mole_v5.py`_)"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:562
msgid "Summary"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:564
msgid "We developed a complete GUI application in 5 well-designed stages. Hopefully you see the value in incremental software development."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:567
msgid "However, the end result is not necessarily easy to understand or modify for future enhancements. The next lesson will introduce a scheme for breaking complete software into more managable pieces."
msgstr ""

