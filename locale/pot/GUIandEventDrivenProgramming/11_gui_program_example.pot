# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014 Brad Miller, David Ranum, Created using Runestone Interactive
# This file is distributed under the same license as the How to Think Like a Computer Scientist package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: How to Think Like a Computer Scientist 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-03-25 15:11-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:16
msgid "A Programming Example"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:18
msgid "Let's develop a non-trivial GUI program to demonstrate the material presented in the previous lessons. We will develop a GUI Whack-a-mole game where a user tries to click on \"moles\" as they randomly pop up out of the \"ground.\""
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:23
msgid "This discussion will take you through an *incremental development* cycle that creates a program in well-defined stages. While you might read a finished computer program from \"top to bottom,\" that is not how it was developed. For a typical GUI program development, you are encouraged to go through these stages:"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:29
msgid "Using scratch paper, physically draw a rough sketch of your user interface."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:30
msgid "Create the basic structure of your program and create the major frames that will hold the widgets needed for your program's interface. Give the frames an initial size and color so that you can visually see them, given that there are no widgets inside of them to determine their size."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:34
msgid "Incrementally add all of the widgets you need for your program and size and position them appropriately."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:36
msgid "Create your callback functions, stub them out, and assign them to appropriate events. Verify that the events are executing the correct functions."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:38
msgid "Incrementally implement the functionality needed for each callback function."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:40
msgid "When you develop code using *incremental development* your program should always be executable. You continually add a few lines of code and then test them. If errors occur you almost always know were the errors came from! They came from the lines of code you just added."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:46
msgid "A Whack-a-mole Game"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:48
msgid "Step 1: Make sure you have a reasonable GUI design and implementation plan before you start coding. Draw a sketch of your initial design on paper and consider how a user will interact with your program."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:55
msgid ".. image:: GUIandEventDrivenProgramming/Figures/Whack_a_mole_design.png"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:55
msgid "Initial design of a Whack-a-mole game"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:57
msgid "Step 2: Create the basic structure of your interface using appropriate ``frame`` widgets. You will need to give a size to the frames because they will contain no widgets, which is how a frame typically gets its size. It is also suggested that you give each frame a unique color so it is easy to see the area of the window it covers. Here is a basic start for our whack-a-mole game (`whack_a_mole_v1.py`_):"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:63
msgid "class WhackAMole:\n"
"\n"
"    def __init__(self):\n"
"        self.window = tk.Tk()\n"
"        self.mole_frame, self.status_frame = self.create_frames()\n"
"\n"
"    def create_frames(self):\n"
"        mole_frame = tk.Frame(self.window, bg='red', width=300, height=300)\n"
"        mole_frame.grid(row=1, column=1)\n"
"\n"
"        status_frame = tk.Frame(self.window, bg='green', width=100, height=300)\n"
"        status_frame.grid(row=1, column=2)\n"
"\n"
"        return mole_frame, status_frame\n"
"\n"
"# Create the GUI program\n"
"program = WhackAMole()\n"
"\n"
"# Start the GUI event loop\n"
"program.window.mainloop()"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:86
msgid "Step 3: Incrementally add appropriate widgets to each frame. Don't attempt to add all the widgets at once. The initial design conceptualized the moles as buttons, so a grid of buttons was added to the left frame, one button for each mole. The exact size of the \"mole field\" needs to be determined at a future time, so initialize a CONSTANT that can be used to easily change it later.  (`whack_a_mole_v2.py`_)"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:93
msgid "import tkinter as tk\n"
"from tkinter import PhotoImage\n"
"\n"
"class WhackAMole:\n"
"    NUM_MOLES_ACROSS = 4\n"
"\n"
"    def __init__(self):\n"
"        self.window = tk.Tk()\n"
"        self.mole_frame, self.status_frame = self.create_frames()\n"
"        self.mole_photo = PhotoImage(file=\"mole.png\")\n"
"        self.mole_buttons = self.create_moles()\n"
"\n"
"    def create_frames(self):\n"
"        mole_frame = tk.Frame(self.window, bg='red')\n"
"        mole_frame.grid(row=1, column=1)\n"
"\n"
"        status_frame = tk.Frame(self.window, bg='green', width=100)\n"
"        status_frame.grid(row=1, column=2, sticky=tk.E + tk.W + tk.N + tk.S)\n"
"\n"
"        return mole_frame, status_frame\n"
"\n"
"    def create_moles(self):\n"
"        # Source of mole image: https://play.google.com/store/apps/details?id=genergame.molehammer\n"
"\n"
"        mole_buttons = []\n"
"        for r in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"            row_of_buttons = []\n"
"            for c in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"                mole_button = tk.Button(self.mole_frame, image=self.mole_photo)\n"
"                mole_button.grid(row=r, column=c, padx=8, pady=8)\n"
"\n"
"                row_of_buttons.append(mole_button)\n"
"\n"
"            mole_buttons.append(row_of_buttons)\n"
"\n"
"        return mole_buttons\n"
"\n"
"# Create the GUI program\n"
"program = WhackAMole()\n"
"\n"
"# Start the GUI event loop\n"
"program.window.mainloop()"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:138
msgid "Continue to add appropriate widgets for the right frame. The final result is shown below, but recognize that it was developed little by little. (`whack_a_mole_v2.py`_)"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:142
msgid "import tkinter as tk\n"
"from tkinter import PhotoImage\n"
"\n"
"\n"
"class WhackAMole:\n"
"    STATUS_BACKGROUND = \"white\"\n"
"    NUM_MOLES_ACROSS = 4\n"
"\n"
"    def __init__(self):\n"
"        self.window = tk.Tk()\n"
"        self.mole_frame, self.status_frame = self.create_frames()\n"
"        self.mole_photo = PhotoImage(file=\"mole.png\")\n"
"        self.mole_buttons = self.create_moles()\n"
"\n"
"        self.hit_counter, self.miss_counter, self.start_button \\\n"
"            = self.create_status_widgets()\n"
"\n"
"    def create_frames(self):\n"
"        mole_frame = tk.Frame(self.window, bg='red')\n"
"        mole_frame.grid(row=1, column=1)\n"
"\n"
"        status_frame = tk.Frame(self.window, bg=WhackAMole.STATUS_BACKGROUND)\n"
"        status_frame.grid(row=1, column=2, sticky=tk.N + tk.S + tk.W + tk.W)\n"
"\n"
"        return mole_frame, status_frame\n"
"\n"
"    def create_moles(self):\n"
"        # Source of mole image: https://play.google.com/store/apps/details?id=genergame.molehammer\n"
"\n"
"        mole_buttons = []\n"
"        for r in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"            row_of_buttons = []\n"
"            for c in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"                mole_button = tk.Button(self.mole_frame, image=self.mole_photo)\n"
"                mole_button.grid(row=r, column=c, padx=8, pady=8)\n"
"\n"
"                row_of_buttons.append(mole_button)\n"
"\n"
"            mole_buttons.append(row_of_buttons)\n"
"\n"
"        return mole_buttons\n"
"\n"
"    def create_status_widgets(self):\n"
"        spacer = tk.Label(self.status_frame, text=\"\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        hit_label = tk.Label(self.status_frame, text=\"Number of Hits\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        hit_label.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        hit_counter = tk.Label(self.status_frame, text=\"0\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        hit_counter.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        miss_label = tk.Label(self.status_frame, text=\"Number of Misses\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        miss_label.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        miss_counter = tk.Label(self.status_frame, text=\"0\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        miss_counter.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        start_button = tk.Button(self.status_frame, text=\"Start\")\n"
"        start_button.pack(side=\"top\", fill=tk.Y, expand=True, ipadx=10)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        quit_button = tk.Button(self.status_frame, text=\"Quit\")\n"
"        quit_button.pack(side=\"top\", fill=tk.Y, expand=True, ipadx=10)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        return hit_counter, miss_counter, start_button\n"
"\n"
"# Create the GUI program\n"
"program = WhackAMole()\n"
"\n"
"# Start the GUI event loop\n"
"program.window.mainloop()"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:228
msgid "Step 4: Create a callback function for each event that will cause something to happen in your program. Stub these functions out with a single print statement in each one. Bind an event to each callback function. Now test your program and make sure each event causes the correct print-line in the Python console. (`whack_a_mole_v4.py`_)"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:234
msgid "import tkinter as tk\n"
"from tkinter import PhotoImage\n"
"\n"
"\n"
"class WhackAMole():\n"
"    STATUS_BACKGROUND = \"white\"\n"
"    NUM_MOLES_ACROSS = 4\n"
"\n"
"    def __init__(self):\n"
"        self.window = tk.Tk()\n"
"        self.mole_frame, self.status_frame = self.create_frames()\n"
"        self.mole_photo = PhotoImage(file=\"mole.png\")\n"
"        self.mole_buttons = self.create_moles()\n"
"\n"
"        self.hit_counter, self.miss_counter, self.start_button, self.quit_button \\\n"
"            = self.create_status_widgets()\n"
"\n"
"        self.set_callbacks()\n"
"\n"
"    def create_frames(self):\n"
"        mole_frame = tk.Frame(self.window, bg='red')\n"
"        mole_frame.grid(row=1, column=1)\n"
"\n"
"        status_frame = tk.Frame(self.window, bg=WhackAMole.STATUS_BACKGROUND)\n"
"        status_frame.grid(row=1, column=2, sticky=tk.E + tk.W + tk.N + tk.S)\n"
"\n"
"        return mole_frame, status_frame\n"
"\n"
"    def create_moles(self):\n"
"        # Source of mole image: https://play.google.com/store/apps/details?id=genergame.molehammer\n"
"\n"
"        mole_buttons = []\n"
"        for r in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"            row_of_buttons = []\n"
"            for c in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"                mole_button = tk.Button(self.mole_frame, image=self.mole_photo)\n"
"                mole_button.grid(row=r, column=c, padx=8, pady=8)\n"
"\n"
"                row_of_buttons.append(mole_button)\n"
"\n"
"            mole_buttons.append(row_of_buttons)\n"
"\n"
"        return mole_buttons\n"
"\n"
"    def create_status_widgets(self):\n"
"        spacer = tk.Label(self.status_frame, text=\"\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        hit_label = tk.Label(self.status_frame, text=\"Number of Hits\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        hit_label.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        hit_counter = tk.Label(self.status_frame, text=\"0\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        hit_counter.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        miss_label = tk.Label(self.status_frame, text=\"Number of Misses\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        miss_label.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        miss_counter = tk.Label(self.status_frame, text=\"0\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        miss_counter.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        start_button = tk.Button(self.status_frame, text=\"Start\")\n"
"        start_button.pack(side=\"top\", fill=tk.Y, expand=True, ipadx=10)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        quit_button = tk.Button(self.status_frame, text=\"Quit\")\n"
"        quit_button.pack(side=\"top\", fill=tk.Y, expand=True, ipadx=10)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\", bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        return hit_counter, miss_counter, start_button, quit_button\n"
"\n"
"    def set_callbacks(self):\n"
"        # Set the same callback for each mole button\n"
"        for r in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"            for c in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"                self.mole_buttons[r][c]['command'] = self.mole_hit\n"
"\n"
"        self.start_button['command'] = self.start\n"
"        self.quit_button['command'] = self.quit\n"
"\n"
"    def mole_hit(self):\n"
"        print(\"mole button hit\")\n"
"\n"
"    def start(self):\n"
"        print(\"start button hit\")\n"
"\n"
"    def quit(self):\n"
"        print(\"quit button hit\")\n"
"\n"
"# Create the GUI program\n"
"program = WhackAMole()\n"
"\n"
"# Start the GUI event loop\n"
"program.window.mainloop()"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:340
msgid "Step 5: Add appropriate functionality to the callback functions. This is where the functional logic of your particular application resides. In the case of our whack-a-mole game, we need to be able to count the number of times a user clicks on a mole when it is visible. And we need the moles to appear and disappear at random intervals. Originally each mole was a button widget, but the border around each button was distracting, so they were changed to label widgets. Two images were used to represent a mole: one image is a solid color that matches the frame's background, and the other image is a picture of a mole. By replacing the image used for each label we can make the moles visible or invisible. A label normally does not have an associated callback, so we ``bind`` a left mouse click event, ``\"<ButtonPress-1>\"`` to each label. We can determine whether the mouse click is a \"hit\" or a \"miss\" by examining the label under the click to see which image is currently set to the label. We use timer events to change the image on each label. Also notice the use of a messagebox to protect the program from accidental quitting. The end result is shown below. (`whack_a_mole_v5.py`_)"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:358
msgid "import tkinter as tk\n"
"from tkinter import PhotoImage\n"
"from tkinter import messagebox\n"
"from random import randint\n"
"\n"
"\n"
"class WhackAMole:\n"
"    STATUS_BACKGROUND = \"white\"\n"
"    NUM_MOLES_ACROSS = 4\n"
"    MIN_TIME_DOWN = 1000\n"
"    MAX_TIME_DOWN = 5000\n"
"    MIN_TIME_UP = 1000\n"
"    MAX_TIME_UP = 3000\n"
"\n"
"    def __init__(self):\n"
"        self.window = tk.Tk()\n"
"        self.window.title(\"Whack-a-mole\")\n"
"\n"
"        self.mole_frame, self.status_frame = self.create_frames()\n"
"\n"
"        self.mole_photo = PhotoImage(file=\"mole.png\")\n"
"        self.mole_cover_photo = PhotoImage(file=\"mole_cover.png\")\n"
"        self.label_timers = {}\n"
"\n"
"        self.mole_labels = self.create_moles()\n"
"\n"
"        self.hit_counter, self.miss_counter, self.start_button, self.quit_button \\\n"
"            = self.create_status_widgets()\n"
"\n"
"        self.set_callbacks()\n"
"        self.game_is_running = False\n"
"\n"
"    def create_frames(self):\n"
"        mole_frame = tk.Frame(self.window)\n"
"        mole_frame.grid(row=0, column=0)\n"
"\n"
"        status_frame = tk.Frame(self.window, bg=WhackAMole.STATUS_BACKGROUND)\n"
"        status_frame.grid(row=0, column=1, sticky=tk.E + tk.W + tk.N + tk.S,\n"
"                          ipadx=6)\n"
"\n"
"        return mole_frame, status_frame\n"
"\n"
"    def create_moles(self):\n"
"        # Source of mole image: https://play.google.com/store/apps/details?id=genergame.molehammer\n"
"\n"
"        mole_labels = []\n"
"        for r in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"            row_of_labels = []\n"
"            for c in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"                mole_label = tk.Label(self.mole_frame, image=self.mole_photo)\n"
"                mole_label.grid(row=r, column=c, sticky=tk.E + tk.W + tk.N + tk.S)\n"
"                self.label_timers[id(mole_label)] = None\n"
"\n"
"                row_of_labels.append(mole_label)\n"
"\n"
"            mole_labels.append(row_of_labels)\n"
"\n"
"        return mole_labels\n"
"\n"
"    def create_status_widgets(self):\n"
"        spacer = tk.Label(self.status_frame, text=\"\",\n"
"                          bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        hit_label = tk.Label(self.status_frame, text=\"Number of Hits\",\n"
"                             bg=WhackAMole.STATUS_BACKGROUND)\n"
"        hit_label.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        hit_counter = tk.Label(self.status_frame, text=\"0\",\n"
"                               bg=WhackAMole.STATUS_BACKGROUND)\n"
"        hit_counter.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\",\n"
"                          bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        miss_label = tk.Label(self.status_frame, text=\"Number of Misses\",\n"
"                              bg=WhackAMole.STATUS_BACKGROUND)\n"
"        miss_label.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        miss_counter = tk.Label(self.status_frame, text=\"0\",\n"
"                                bg=WhackAMole.STATUS_BACKGROUND)\n"
"        miss_counter.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\",\n"
"                          bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        start_button = tk.Button(self.status_frame, text=\"Start\")\n"
"        start_button.pack(side=\"top\", fill=tk.Y, expand=True, ipadx=10)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\",\n"
"                          bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        quit_button = tk.Button(self.status_frame, text=\"Quit\")\n"
"        quit_button.pack(side=\"top\", fill=tk.Y, expand=True, ipadx=10)\n"
"\n"
"        spacer = tk.Label(self.status_frame, text=\"\",\n"
"                          bg=WhackAMole.STATUS_BACKGROUND)\n"
"        spacer.pack(side=\"top\", fill=tk.Y, expand=True)\n"
"\n"
"        return hit_counter, miss_counter, start_button, quit_button\n"
"\n"
"    def set_callbacks(self):\n"
"        # Set the same callback for each mole label\n"
"        for r in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"            for c in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"                self.mole_labels[r][c].bind(\"<ButtonPress-1>\", self.mole_hit)\n"
"\n"
"        self.start_button['command'] = self.start\n"
"        self.quit_button['command'] = self.quit\n"
"\n"
"    def mole_hit(self, event):\n"
"\n"
"        if self.game_is_running:\n"
"            hit_label = event.widget\n"
"            if hit_label['image'] == self.mole_cover_photo.name:\n"
"                # MISSED! Update the miss counter\n"
"                self.miss_counter['text'] = str(int(self.miss_counter['text']) + 1)\n"
"            else:\n"
"                # HIT! Update the hit counter\n"
"                self.hit_counter['text'] = str(int(self.hit_counter['text']) + 1)\n"
"                # Remove the mole and don't update the miss counter\n"
"                self.put_down_mole(hit_label, False)\n"
"\n"
"    def start(self):\n"
"        if self.start_button['text'] == 'Start':\n"
"            # Change all the mole images to a blank image and\n"
"            # set a random time for the moles to re-appear on each label.\n"
"            for r in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"                for c in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"                    the_label = self.mole_labels[r][c]\n"
"                    the_label['image'] = self.mole_cover_photo\n"
"                    time_down = randint(WhackAMole.MIN_TIME_DOWN,\n"
"                                        WhackAMole.MAX_TIME_DOWN)\n"
"                    timer_object = the_label.after(time_down,\n"
"                                                   self.pop_up_mole, the_label)\n"
"                    self.label_timers[id(the_label)] = timer_object\n"
"\n"
"            self.game_is_running = True\n"
"            self.start_button['text'] = \"Stop\"\n"
"\n"
"            self.hit_counter['text'] = \"0\"\n"
"            self.miss_counter['text'] = \"0\"\n"
"\n"
"        else:  # The game is running, so stop the game and reset everything\n"
"            # Show every mole and stop all the timers\n"
"            for r in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"                for c in range(WhackAMole.NUM_MOLES_ACROSS):\n"
"                    the_label = self.mole_labels[r][c]\n"
"                    # Show the mole\n"
"                    the_label['image'] = self.mole_photo\n"
"                    # Delete any timer that is associated with the mole\n"
"                    the_label.after_cancel(self.label_timers[id(the_label)])\n"
"\n"
"            self.game_is_running = False\n"
"            self.start_button['text'] = \"Start\"\n"
"\n"
"    def put_down_mole(self, the_label, timer_expired):\n"
"\n"
"        if self.game_is_running:\n"
"            if timer_expired:\n"
"                # The mole is going down before it was clicked on, so update the miss counter\n"
"                self.miss_counter['text'] = str(int(self.miss_counter['text']) + 1)\n"
"            else:\n"
"                # The timer did not expire, so manually stop the timer\n"
"                the_label.after_cancel(self.label_timers[id(the_label)])\n"
"\n"
"            # Make the mole invisible\n"
"            the_label['image'] = self.mole_cover_photo\n"
"\n"
"            # Set a call to pop up the mole in the future\n"
"            time_down = randint(WhackAMole.MIN_TIME_DOWN,\n"
"                                WhackAMole.MAX_TIME_DOWN)\n"
"            timer_object = the_label.after(time_down, self.pop_up_mole, the_label)\n"
"            # Remember the timer object so it can be canceled later, if need be\n"
"            self.label_timers[id(the_label)] = timer_object\n"
"\n"
"    def pop_up_mole(self, the_label):\n"
"        # Show the mole on the screen\n"
"        the_label['image'] = self.mole_photo\n"
"\n"
"        if self.game_is_running:\n"
"            # Set a call to make the mole disappear in the future\n"
"            time_up = randint(WhackAMole.MIN_TIME_UP, WhackAMole.MAX_TIME_UP)\n"
"            timer_object = the_label.after(time_up, self.put_down_mole,\n"
"                                           the_label, True)\n"
"            self.label_timers[id(the_label)] = timer_object\n"
"\n"
"    def quit(self):\n"
"        really_quit = messagebox.askyesno(\"Quiting?\", \"Do you really want to quit?\")\n"
"        if really_quit:\n"
"            self.window.destroy()\n"
"\n"
"# Create the GUI program\n"
"program = WhackAMole()\n"
"\n"
"# Start the GUI event loop\n"
"program.window.mainloop()"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:562
msgid "Summary"
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:564
msgid "We developed a complete GUI application in 5 well-designed stages. Hopefully you see the value in incremental software development."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:567
msgid "However, the end result is not necessarily easy to understand or modify for future enhancements. The next lesson will introduce a scheme for breaking complete software into more managable pieces."
msgstr ""

#: ../../_sources/GUIandEventDrivenProgramming/11_gui_program_example.rst:571
msgid "Whack-a-mole game"
msgstr ""

