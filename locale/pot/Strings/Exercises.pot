# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014 Brad Miller, David Ranum, Created using Runestone Interactive
# This file is distributed under the same license as the How to Think Like a Computer Scientist package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: How to Think Like a Computer Scientist 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-03-26 21:02-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../_sources/Strings/Exercises.rst:11
msgid "Exercises"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:19
msgid "What is the result of each of the following:"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:21
msgid "'Python'[1]"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:22
msgid "\"Strings are sequences of characters.\"[5]"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:23
msgid "len(\"wonderful\")"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:24
msgid "'Mystery'[:4]"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:25
msgid "'p' in 'Pineapple'"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:26
msgid "'apple' in 'Pineapple'"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:27
msgid "'pear' not in 'Pineapple'"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:28
msgid "'apple' > 'pineapple'"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:29
msgid "'pineapple' < 'Peach'"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:33
msgid "'Python'[1] = 'y'"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:34
msgid "'Strings are sequences of characters.'[5] = 'g'"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:35
msgid "len('wonderful') = 9"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:36
msgid "'Mystery'[:4] = 'Myst'"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:37
msgid "'p' in 'Pineapple' = True"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:38
msgid "'apple' in 'Pineapple' = True"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:39
msgid "'pear' not in 'Pineapple' = True"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:40
msgid "'apple' > 'pineapple' = False"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:41
msgid "'pineapple' < 'Peach' = False"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:50
msgid "In Robert McCloskey's book *Make Way for Ducklings*, the names of the ducklings are Jack, Kack, Lack, Mack, Nack, Ouack, Pack, and Quack.  This loop tries to output these names in order."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:54
msgid "prefixes = \"JKLMNOPQ\"\n"
"suffix = \"ack\"\n"
"\n"
"for p in prefixes:\n"
"    print(p + suffix)"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:63
msgid "Of course, that's not quite right because Ouack and Quack are misspelled. Can you fix it?"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:67
#: ../../_sources/Strings/Exercises.rst:85
#: ../../_sources/Strings/Exercises.rst:114
#: ../../_sources/Strings/Exercises.rst:127
#: ../../_sources/Strings/Exercises.rst:155
#: ../../_sources/Strings/Exercises.rst:169
#: ../../_sources/Strings/Exercises.rst:201
#: ../../_sources/Strings/Exercises.rst:229
#: ../../_sources/Strings/Exercises.rst:252
#: ../../_sources/Strings/Exercises.rst:286
#: ../../_sources/Strings/Exercises.rst:318
#: ../../_sources/Strings/Exercises.rst:344
#: ../../_sources/Strings/Exercises.rst:382
#: ../../_sources/Strings/Exercises.rst:412
#: ../../_sources/Strings/Exercises.rst:433
#: ../../_sources/Strings/Exercises.rst:467
#: ../../_sources/Strings/Exercises.rst:481
#: ../../_sources/Strings/Exercises.rst:542
#: ../../_sources/Strings/Exercises.rst:560
#: ../../_sources/Strings/Exercises.rst:574
#: ../../_sources/Strings/Exercises.rst:632
#: ../../_sources/Strings/Exercises.rst:650
#: ../../_sources/Strings/Exercises.rst:664
#: ../../_sources/Strings/Exercises.rst:728
#: ../../_sources/Strings/Exercises.rst:746
#: ../../_sources/Strings/Exercises.rst:758
#: ../../_sources/Strings/Exercises.rst:793
#: ../../_sources/Strings/Exercises.rst:827
#: ../../_sources/Strings/Exercises.rst:849
#: ../../_sources/Strings/Exercises.rst:871
msgid ""
msgstr ""

#: ../../_sources/Strings/Exercises.rst:67
#: ../../_sources/Strings/Exercises.rst:127
#: ../../_sources/Strings/Exercises.rst:481
#: ../../_sources/Strings/Exercises.rst:560
#: ../../_sources/Strings/Exercises.rst:574
#: ../../_sources/Strings/Exercises.rst:650
#: ../../_sources/Strings/Exercises.rst:664
#: ../../_sources/Strings/Exercises.rst:746
#: ../../_sources/Strings/Exercises.rst:758
msgid "\n"
""
msgstr ""

#: ../../_sources/Strings/Exercises.rst:74
msgid "Assign to a variable in your program a triple-quoted string that contains your favorite paragraph of text - perhaps a poem, a speech, instructions to bake a cake, some inspirational verses, etc."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:78
msgid "Write a function that counts the number of alphabetic characters (a through z, or A through Z) in your text and then keeps track of how many are the letter 'e'.  Your function should print an analysis of the text like this::"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:85
msgid "def count(p):\n"
"    # your code here"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:114
msgid "def count(p):\n"
"    lows = \"abcdefghijklmnopqrstuvwxyz\"\n"
"    ups =  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n"
"\n"
"    numberOfe = 0\n"
"    totalChars = 0\n"
"    for achar in p:\n"
"        if achar in lows or achar in ups:\n"
"            totalChars = totalChars + 1\n"
"            if achar == 'e':\n"
"                numberOfe = numberOfe + 1\n"
"\n"
"    percent_with_e = (numberOfe / totalChars) * 100\n"
"    print(\"Your text contains\", totalChars, \"alphabetic characters of which\", numberOfe, \"(\", percent_with_e, \"%)\", \"are 'e'.\")\n"
"\n"
"\n"
"p = '''\n"
"\"If the automobile had followed the same development cycle as the computer, a\n"
"Rolls-Royce would today cost $100, get a million miles per gallon, and explode\n"
"once a year, killing everyone inside.\"\n"
"-Robert Cringely\n"
"'''\n"
"\n"
"count(p)"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:123
msgid "Print out a neatly formatted multiplication table, up to 12 x 12."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:134
msgid "Write a function that will return the number of digits in an integer."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:155
msgid "def numDigits(n):\n"
"    # your code here\n"
"\n"
"====\n"
"\n"
"from unittest.gui import TestCaseGui\n"
"\n"
"class myTests(TestCaseGui):\n"
"\n"
"  def testOne(self):\n"
"      self.assertEqual(numDigits(2),1,\"Tested numDigits on input of 2\")\n"
"      self.assertEqual(numDigits(55),2,\"Tested numDigits on input of 55\")\n"
"      self.assertEqual(numDigits(1352),4,\"Tested numDigits on input of 1352\")\n"
"      self.assertEqual(numDigits(444),3,\"Tested numDigits on input of 444\")\n"
"\n"
"\n"
"\n"
"myTests().main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:169
msgid "def numDigits(n):\n"
"    n_str = str(n)\n"
"    return len(n_str)\n"
"\n"
"\n"
"print(numDigits(50))\n"
"print(numDigits(20000))\n"
"print(numDigits(1))"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:178
msgid "Write a function that reverses its string argument."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:201
msgid "def reverse(astring):\n"
"    # your code here\n"
"\n"
"====\n"
"\n"
"from unittest.gui import TestCaseGui\n"
"\n"
"class myTests(TestCaseGui):\n"
"\n"
"  def testOne(self):\n"
"      self.assertEqual(reverse(\"happy\"),\"yppah\",\"Tested reverse on input of 'happy'\")\n"
"      self.assertEqual(reverse(\"Python\"),\"nohtyP\",\"Tested reverse on input of 'Python'\")\n"
"      self.assertEqual(reverse(\"\"),\"\",\"Tested reverse on input of ''\")\n"
"\n"
"\n"
"\n"
"\n"
"myTests().main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:208
msgid "Write a function that mirrors its argument."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:229
msgid "def mirror(mystr):\n"
"    # your code here\n"
"\n"
"====\n"
"\n"
"from unittest.gui import TestCaseGui\n"
"\n"
"class myTests(TestCaseGui):\n"
"\n"
"    def testOne(self):\n"
"        self.assertEqual(mirror(\"good\"),\"gooddoog\",\"Tested mirror on input of 'good'\")\n"
"        self.assertEqual(mirror(\"Python\"),\"PythonnohtyP\",\"Tested mirror on input of 'Python'\")\n"
"        self.assertEqual(mirror(\"\"),\"\",\"Tested mirror on input of ''\")\n"
"        self.assertEqual(mirror(\"a\"),\"aa\",\"Tested mirror on input of 'a'\")\n"
"\n"
"\n"
"myTests().main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:252
msgid "from test import testEqual\n"
"\n"
"def reverse(mystr):\n"
"    reversed = ''\n"
"    for char in mystr:\n"
"        reversed = char + reversed\n"
"    return reversed\n"
"\n"
"def mirror(mystr):\n"
"    return mystr + reverse(mystr)\n"
"\n"
"testEqual(mirror('good'), 'gooddoog')\n"
"testEqual(mirror('Python'), 'PythonnohtyP')\n"
"testEqual(mirror(''), '')\n"
"testEqual(mirror('a'), 'aa')"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:261
msgid "Write a function that removes all occurrences of a given letter from a string."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:286
msgid "def remove_letter(theLetter, theString):\n"
"    # your code here\n"
"\n"
"====\n"
"\n"
"\n"
"from unittest.gui import TestCaseGui\n"
"\n"
"class myTests(TestCaseGui):\n"
"\n"
"  def testOne(self):\n"
"      self.assertEqual(remove_letter(\"a\",\"apple\"),\"pple\",\"Tested remove_letter on inputs of 'a' and 'apple'\")\n"
"      self.assertEqual(remove_letter(\"a\",\"banana\"),\"bnn\",\"Tested remove_letter on inputs of 'a' and 'banana'\")\n"
"      self.assertEqual(remove_letter(\"z\",\"banana\"),\"banana\",\"Tested remove_letter on inputs of 'z' and 'banana'\")\n"
"\n"
"\n"
"\n"
"myTests().main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:293
msgid "Write a function that recognizes palindromes. (Hint: use your ``reverse`` function to make this easy!)."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:318
msgid "def is_palindrome(myStr):\n"
"    # your code here\n"
"\n"
"====\n"
"\n"
"\n"
"from unittest.gui import TestCaseGui\n"
"\n"
"class myTests(TestCaseGui):\n"
"\n"
"    def testOne(self):\n"
"        self.assertEqual(is_palindrome(\"abba\"),True,\"Tested is_palindrome on input of 'abba'\")\n"
"        self.assertEqual(is_palindrome(\"abab\"),False,\"Tested is_palindrome on input of 'abab'\")\n"
"        self.assertEqual(is_palindrome(\"straw warts\"),True,\"Tested is_palindrome on input of 'straw warts'\")\n"
"        self.assertEqual(is_palindrome(\"a\"),True,\"Tested is_palindrome on input of 'a'\")\n"
"        self.assertEqual(is_palindrome(\"\"),True,\"Tested is_palindrome on input of ''\")\n"
"\n"
"\n"
"\n"
"\n"
"myTests().main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:344
msgid "from test import testEqual\n"
"\n"
"def reverse(mystr):\n"
"    reversed = ''\n"
"    for char in mystr:\n"
"        reversed = char + reversed\n"
"    return reversed\n"
"\n"
"def is_palindrome(myStr):\n"
"    if myStr in reverse(myStr):\n"
"        return True\n"
"    else:\n"
"        return False\n"
"\n"
"testEqual(is_palindrome('abba'), True)\n"
"testEqual(is_palindrome('abab'), False)\n"
"testEqual(is_palindrome('straw warts'), True)\n"
"testEqual(is_palindrome('a'), True)\n"
"testEqual(is_palindrome(''), True)"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:353
msgid "Write a function that counts how many times a substring occurs in a string."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:382
msgid "def count(substr,theStr):\n"
"    # your code here\n"
"\n"
"\n"
"====\n"
"\n"
"\n"
"from unittest.gui import TestCaseGui\n"
"\n"
"class myTests(TestCaseGui):\n"
"\n"
"      def testOne(self):\n"
"          self.assertEqual(count(\"is\",\"Mississippi\"),2,\"Tested count on inputs of 'is' and 'Mississippi'\")\n"
"          self.assertEqual(count(\"an\",\"banana\"),2,\"Tested count on inputs of 'an' and 'banana'\")\n"
"          self.assertEqual(count(\"ana\",\"banana\"),2,\"Tested count on inputs of 'ana' and 'banana'\")\n"
"          self.assertEqual(count(\"nana\",\"banana\"),1,\"Tested count on inputs of 'nana' and 'banana'\")\n"
"          self.assertEqual(count(\"nanan\",\"banana\"),0,\"Tested count on inputs of 'nanan' and 'banana'\")\n"
"          self.assertEqual(count(\"aaa\",\"aaaaaa\"),4,\"Tested count on input of 'aaa' and 'aaaaaa'\")\n"
"\n"
"\n"
"\n"
"\n"
"myTests().main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:389
msgid "Write a function that removes the first occurrence of a string from another string."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:412
msgid "def remove(substr,theStr):\n"
"    # your code here\n"
"\n"
"====\n"
"\n"
"\n"
"from unittest.gui import TestCaseGui\n"
"\n"
"class myTests(TestCaseGui):\n"
"\n"
"        def testOne(self):\n"
"            self.assertEqual(remove(\"an\",\"banana\"),\"bana\",\"Tested remove on inputs of 'an' and 'banana'\")\n"
"            self.assertEqual(remove(\"cyc\",\"bicycle\"),\"bile\",\"Tested remove on inputs of 'cyc' and 'bicycle'\")\n"
"            self.assertEqual(remove(\"iss\",\"Mississippi\"),\"Missippi\",\"Tested remove on inputs of 'iss' and 'Mississippi'\")\n"
"            self.assertEqual(remove(\"egg\",\"bicycle\"),\"bicycle\",\"Tested remove on inputs of 'egg' and 'bicycle'\")\n"
"\n"
"\n"
"\n"
"myTests().main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:433
msgid "from test import testEqual\n"
"\n"
"def remove(substr,theStr):\n"
"    index = theStr.find(substr)\n"
"    if index < 0: # substr doesn't exist in theStr\n"
"        return theStr\n"
"    return_str = theStr[:index] + theStr[index+len(substr):]\n"
"    return return_str\n"
"\n"
"testEqual(remove('an', 'banana'), 'bana')\n"
"testEqual(remove('cyc', 'bicycle'), 'bile')\n"
"testEqual(remove('iss', 'Mississippi'), 'Missippi')\n"
"testEqual(remove('egg', 'bicycle'), 'bicycle')"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:442
msgid "Write a function that removes all occurrences of a string from another string."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:467
msgid "def remove_all(substr,theStr):\n"
"    # your code here\n"
"\n"
"\n"
"\n"
"====\n"
"\n"
"from unittest.gui import TestCaseGui\n"
"\n"
"class myTests(TestCaseGui):\n"
"\n"
"  def testOne(self):\n"
"      self.assertEqual(remove_all(\"an\",\"banana\"),\"ba\",\"Tested remove_all on inputs of 'an' and 'banana'\")\n"
"      self.assertEqual(remove_all(\"cyc\",\"bicycle\"),\"bile\",\"Tested remove_all on inputs of 'cyc' and 'bicycle'\")\n"
"      self.assertEqual(remove_all(\"iss\",\"Mississippi\"),\"Mippi\",\"Tested remove_all on inputs of 'iss' and 'Mississippi'\")\n"
"      self.assertEqual(remove_all(\"eggs\",\"bicycle\"),\"bicycle\",\"Tested remove_all on inputs of 'eggs' and 'bicycle'\")\n"
"\n"
"\n"
"\n"
"myTests().main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:474
msgid "Here is another interesting L-System called a Hilbert curve.  Use 90 degrees::"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:542
msgid "import turtle\n"
"\n"
"def createLSystem(numIters, axiom):\n"
"    startString = axiom\n"
"    endString = \"\"\n"
"    for i in range(numIters):\n"
"        endString = processString(startString)\n"
"        startString = endString\n"
"\n"
"    return endString\n"
"\n"
"def processString(oldStr):\n"
"    newstr = \"\"\n"
"    for ch in oldStr:\n"
"        newstr = newstr + applyRules(ch)\n"
"\n"
"    return newstr\n"
"\n"
"def applyRules(ch):\n"
"    newstr = \"\"\n"
"    if ch == 'L':\n"
"        newstr = '+RF-LFL-FR+'   # Rule 1\n"
"    elif ch == 'R':\n"
"        newstr = '-LF+RFR+FL-'\n"
"    else:\n"
"        newstr = ch     # no rules apply so keep the character\n"
"\n"
"    return newstr\n"
"\n"
"def drawLsystem(aTurtle, instructions, angle, distance):\n"
"    for cmd in instructions:\n"
"        if cmd == 'F':\n"
"            aTurtle.forward(distance)\n"
"        elif cmd == 'B':\n"
"            aTurtle.backward(distance)\n"
"        elif cmd == '+':\n"
"            aTurtle.right(angle)\n"
"        elif cmd == '-':\n"
"            aTurtle.left(angle)\n"
"\n"
"def main():\n"
"    inst = createLSystem(4, \"L\")  # create the string\n"
"    print(inst)\n"
"    t = turtle.Turtle()           # create the turtle\n"
"    wn = turtle.Screen()\n"
"\n"
"    t.up()\n"
"    t.back(200)\n"
"    t.down()\n"
"    t.speed(9)\n"
"    drawLsystem(t, inst, 90, 5)   # draw the picture\n"
"                                  # angle 90, segment length 5\n"
"    wn.exitonclick()\n"
"\n"
"main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:552
msgid "Here is a dragon curve.  Use 90 degrees.::"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:567
msgid "Here is something called an arrowhead curve.  Use 60 degrees.::"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:632
msgid "import turtle\n"
"\n"
"def createLSystem(numIters, axiom):\n"
"    startString = axiom\n"
"    endString = \"\"\n"
"    for i in range(numIters):\n"
"        endString = processString(startString)\n"
"        startString = endString\n"
"\n"
"    return endString\n"
"\n"
"def processString(oldStr):\n"
"    newstr = \"\"\n"
"    for ch in oldStr:\n"
"        newstr = newstr + applyRules(ch)\n"
"\n"
"    return newstr\n"
"\n"
"def applyRules(ch):\n"
"    newstr = \"\"\n"
"    if ch == 'X':\n"
"        newstr = 'YF+XF+Y'   # Rule 1\n"
"    elif ch == 'Y':\n"
"        newstr = 'XF-YF-X'\n"
"    else:\n"
"        newstr = ch     # no rules apply so keep the character\n"
"\n"
"    return newstr\n"
"\n"
"def drawLsystem(aTurtle, instructions, angle, distance):\n"
"    for cmd in instructions:\n"
"        if cmd == 'F':\n"
"            aTurtle.forward(distance)\n"
"        elif cmd == 'B':\n"
"            aTurtle.backward(distance)\n"
"        elif cmd == '+':\n"
"            aTurtle.right(angle)\n"
"        elif cmd == '-':\n"
"            aTurtle.left(angle)\n"
"\n"
"def main():\n"
"    inst = createLSystem(5, \"YF\")  # create the string\n"
"    print(inst)\n"
"    t = turtle.Turtle()            # create the turtle\n"
"    wn = turtle.Screen()\n"
"\n"
"    t.speed(9)\n"
"    drawLsystem(t, inst, 60, 5)    # draw the picture\n"
"                                   # angle 90, segment length 5\n"
"    wn.exitonclick()\n"
"\n"
"main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:642
msgid "Try the Peano-Gosper curve.  Use 60 degrees.::"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:657
msgid "The Sierpinski Triangle.  Use 60 degrees.::"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:728
msgid "import turtle\n"
"\n"
"def createLSystem(numIters, axiom):\n"
"    startString = axiom\n"
"    endString = \"\"\n"
"    for i in range(numIters):\n"
"        endString = processString(startString)\n"
"        startString = endString\n"
"\n"
"    return endString\n"
"\n"
"def processString(oldStr):\n"
"    newstr = \"\"\n"
"    for ch in oldStr:\n"
"        newstr = newstr + applyRules(ch)\n"
"\n"
"    return newstr\n"
"\n"
"def applyRules(ch):\n"
"    newstr = \"\"\n"
"    if ch == 'F':\n"
"        newstr = 'FF'   # Rule 1\n"
"    elif ch == 'X':\n"
"        newstr = '--FXF++FXF++FXF--'\n"
"    else:\n"
"        newstr = ch     # no rules apply so keep the character\n"
"\n"
"    return newstr\n"
"\n"
"def drawLsystem(aTurtle, instructions, angle, distance):\n"
"    for cmd in instructions:\n"
"        if cmd == 'F':\n"
"            aTurtle.forward(distance)\n"
"        elif cmd == 'B':\n"
"            aTurtle.backward(distance)\n"
"        elif cmd == '+':\n"
"            aTurtle.right(angle)\n"
"        elif cmd == '-':\n"
"            aTurtle.left(angle)\n"
"\n"
"def main():\n"
"    inst = createLSystem(5, \"FXF--FF--FF\")   # create the string\n"
"    print(inst)\n"
"    t = turtle.Turtle()           # create the turtle\n"
"    wn = turtle.Screen()\n"
"    t.up()\n"
"    t.back(200)\n"
"    t.right(90)\n"
"    t.forward(100)\n"
"    t.left(90)\n"
"    t.down()\n"
"    t.speed(9)\n"
"\n"
"    drawLsystem(t, inst, 60, 5)   # draw the picture\n"
"                                  # angle 90, segment length 5\n"
"    wn.exitonclick()\n"
"\n"
"main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:738
msgid "Write a function that implements a substitution cipher.  In a substitution cipher one letter is substituted for another to garble the message.  For example A -> Q, B -> T, C -> G etc.  your function should take two parameters, the message you want to encrypt, and a string that represents the mapping of the 26 letters in the alphabet.  Your function should return a string that is the encrypted version of the message."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:753
msgid "Write a function that decrypts the message from the previous exercise.  It should also take two parameters.  The encrypted message, and the mixed up alphabet.  The function should return a string that is the same as the original unencrypted message."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:793
msgid "def encrypt(message, cipher):\n"
"    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n"
"    encrypted = ''\n"
"    for char in message:\n"
"        if char == ' ':\n"
"            encrypted = encrypted + ' '\n"
"        else:\n"
"            pos = alphabet.index(char)\n"
"            encrypted = encrypted + cipher[pos]\n"
"    return encrypted\n"
"\n"
"def decrypt(encrypted, cipher):\n"
"    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n"
"    decrypted = ''\n"
"    for char in encrypted:\n"
"        if char == ' ':\n"
"            decrypted = decrypted + ' '\n"
"        else:\n"
"            pos = cipher.index(char)\n"
"            decrypted = decrypted + alphabet[pos]\n"
"    return decrypted\n"
"\n"
"\n"
"cipher = \"badcfehgjilknmporqtsvuxwzy\"\n"
"\n"
"encrypted = encrypt('hello world', cipher)\n"
"print encrypted\n"
"\n"
"decrypted = decrypt(encrypted, cipher)\n"
"print(decrypted)"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:802
msgid "Write a function called  ``remove_dups`` that takes a string and creates a new string by only adding those characters that are not already present.  In other words, there will never be a duplicate letter added to the new string."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:827
msgid "def remove_dups(astring):\n"
"    # your code here\n"
"\n"
"\n"
"print(remove_dups(\"mississippi\"))   #should print misp\n"
"\n"
"====\n"
"from unittest.gui import TestCaseGui\n"
"\n"
"class myTests(TestCaseGui):\n"
"\n"
"  def testOne(self):\n"
"      self.assertEqual(remove_dups(\"pooh\"),\"ph\",\"Tested remove_dups on string 'pooh'\")\n"
"      self.assertEqual(remove_dups(\"mississippi\"),\"misp\",\"Tested remove_dups on string 'mississippi'\")\n"
"      self.assertEqual(remove_dups(\"potato\"),\"pota\",\"Tested remove_dups on string 'potato'\")\n"
"      self.assertEqual(remove_dups(\"bookkeeper\"),\"bokepr\",\"Tested remove_dups on string 'bookkeeper'\")\n"
"      self.assertEqual(remove_dups(\"oo\"),\"\",\"Tested remove_dups on string 'oo'\")\n"
"\n"
"myTests().main()"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:834
msgid "Write a function called ``rot13`` that uses the Caesar cipher to encrypt a message. The Caesar cipher works like a substitution cipher but each character is replaced by the character 13 characters to 'its right' in the alphabet.  So for example the letter a becomes the letter n.  If a letter is past the middle of the alphabet then the counting wraps around to the letter a again, so n becomes a, o becomes b and so on.  *Hint:* Whenever you talk about things wrapping around its a good idea to think of modulo arithmetic."
msgstr ""

#: ../../_sources/Strings/Exercises.rst:849
msgid "def rot13(mess):\n"
"    # Your code here\n"
"\n"
"print(rot13('abcde'))\n"
"print(rot13('nopqr'))\n"
"print(rot13(rot13('Since rot13 is symmetric you should see this message')))"
msgstr ""

#: ../../_sources/Strings/Exercises.rst:871
msgid "def rot13(mess):\n"
"    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n"
"    encrypted = ''\n"
"    for char in mess:\n"
"        if char == ' ':\n"
"            encrypted = encrypted + ' '\n"
"        else:\n"
"            rotated_index = alphabet.index(char) + 13\n"
"            if rotated_index < 26:\n"
"                encrypted = encrypted + alphabet[rotated_index]\n"
"            else:\n"
"                encrypted = encrypted + alphabet[rotated_index % 26]\n"
"    return encrypted\n"
"\n"
"print(rot13('abcde'))\n"
"print(rot13('nopqr'))\n"
"print(rot13(rot13('since rot thirteen is symmetric you should see this message')))"
msgstr ""

